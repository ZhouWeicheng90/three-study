### 纹理

#### 使用基础

```js
TextureLoader // 先new再加载，可以重复使用加载器
ImageLoader  // 加载图片后，直接创建纹理：
	var texture = new THREE.Texture(img);  // 必须设置 texture.needsUpdate = true; 纹理才可用
ObjectLoader
	loader.load('model.json',function (obj) {...}  // 得到的obj是一个可以加入scene的Object3D
    // 需要json遵循 three.js规则
// 同步加载：
    var texture = textureLoader.load(url);  // 另外两个loader可以这样吗？
    // 经过测试，这样加载最开始的纹理时黑色的，过一会等纹理正在加载好了，才是正常的。                                              
// canvas纹理：
let texture = new THREE.CanvasTexture(canvas);  // canvas可以不在document中！ 可以使用canvas的2d功能！
// video纹理
let texture = new THREE.VideoTexture(video);  // 普通的 <video/>                                             
                                             

material.map
// 使用：
// 材质的 map 属性设为纹理 texture
// 一个已经画出来了的模型可以动态修改其纹理:
	mesh.material.map = texture2; // 需要再次调用render
// color设置 会和纹理综合作用！！！                                            


纹理坐标:
// 将图片的像素位置，映射到 [-1,1]*[-1,1]的区间上，然后设置几何体每个顶点对应的图片坐标（即纹理坐标）
// 纹理是一个独立的对象，几何体对象的每个顶点有对应的纹理坐标（默认就是自身的归一化的坐标）

设置顶点对应的纹理：
// Geometry 的 faceVertexUvs : 
	// geometry.faceVertexUvs[0][0]=[v2_1, v2_2, v2_3]  
	// 每个v2是 new THREE.Vector2(0.2,0.2)这样的 x,y都在[0,1]之间。
	// 每个face有3个顶点，所以有3个纹理坐标与之对应
// BufferGeometry 的 attributes.uv
	// geometry.attributes.uv = new THREE.BufferAttribute(arr, 2);
	// arr就是 [x1,y1,x2,y2,…………]这样的数组


```

#### 数组材质

```js
var mesh = new THREE.Mesh(geometry, materialArr);
	// 多个材质，但每个三角形绘制时只能使用一个
	// 这由每个face的materialIndex决定
	geometry.faces[4].materialIndex = 1;
	bufferGeometry.groups // bufferGeo由groups配置决定，这个配置较灵活，例：
	bufferGeometry.groups[i] = {start:0,count:9,materialIndex:1} // 表示从第0个顶点开始，一共9个顶点（即3个三角形）采用第1个材质。

// 内置的几何体，如box，sphere 都有默认的materialIndex设置！（立方体6个面，12个三角形都设了）
```

#### 纹理的变换处理

纹理可不只是傻傻的加载一张图片就可以了！

```js
// 重复列阵：
texture.wrapS = THREE.RepeatWrapping;  // 设置水平方向的重复方式
texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set(4, 2);   // 水平方向重复4个，垂直2个（4*2）
texture.repeat.x = 20;
texture.repeat= new THREE.Vector2(20,1)

// 偏移
texture.offset = new THREE.Vector2(0.3, 0.1)
texture.offset.set(0.25,0.25);

// 偏移与列阵同时设置时，注意偏移的始终是单个图片，列阵不过是重复，列阵不是产生新的图片！
```

```js
texture.rotation = Math.PI / 3;
texture.center.set(0.5, 0.5); // 设置纹理的旋转中心，默认(0,0)
```

#### 其他纹理

普通的纹理对象，配置在不同的属性上，表达的信息不同

##### 凸凹纹理和法线纹理

```js
// 法线纹理：图片的rgb分量表示的是法线xyz，从而图片描述了物体表面的凸凹细节！
normalMap: normalMap,
normalScale: new THREE.Vector2( 0.8, 0.8 )  // 表示深浅程度

// 凸凹纹理： 图片像素的灰度值 描述物体表面的凸凹细节！
bumpMap: bumpMap,
bumpScale: 12   // 表示深浅程度

// 注意：
// 凸凹纹理，法线纹理，在 MeshBasicMaterial和MeshLambertMaterial中不存在！！存在于具有高光属性的材质中！
// 这两个纹理 都是表达表面凹凸细节的，但显然表达方向的法线贴图信息更丰富。
// 如果写了两个将采用法线纹理，忽略凸凹纹理。
```

##### 光照贴图（或阴影贴图）

``` js
// 设置阴影，通常无需设置
lightMap: textureLight  // 设置的是【阴影区域的纹理】，所以通常在 receiveShadow 的地方设置！
// 阴影贴图 和 普通的贴图基本一样，不过相反的是：光线越弱，贴图越明显。

第2套纹理坐标:
// 贴图就要有纹理坐标，阴影纹理坐标就是【第2套纹理坐标】
// 通常可以直接采用第一套纹理坐标(用于普通纹理，法线纹理等) 作为阴影的纹理坐标，于是通常这么设置：
bufferGeometry.attributes.uv2 = bufferGeometry.attributes.uv;  
geometry.faceVertexUvs[1] = geometry.faceVertexUvs[0];  
```



### 待强化

spotLight和directionalLight的方向该怎么设置？？———— 手电筒，发光镜

LightHelper的设置



高光材质的使用（透明度玻璃管？？）

纹理的旋转



http://localhost:8080/examples/#webxr_vr_panorama_depth

http://localhost:8080/examples/#webxr_vr_panorama

http://localhost:8080/examples/#webxr_vr_rollercoaster

http://localhost:8080/examples/#webxr_vr_sandbox

http://localhost:8080/examples/#physics_ammo_terrain

