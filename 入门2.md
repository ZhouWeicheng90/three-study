### 纹理

#### 使用基础

```js
TextureLoader // 先new再加载，可以重复使用加载器
ImageLoader  // 加载图片后，直接创建纹理：
	var texture = new THREE.Texture(img);  // 必须设置 texture.needsUpdate = true; 纹理才可用
ObjectLoader
	loader.load('model.json',function (obj) {...}  // 得到的obj是一个可以加入scene的Object3D
    // 需要json遵循 three.js规则
// 同步加载：
    var texture = textureLoader.load(url);  // 另外两个loader可以这样吗？
    // 经过测试，这样加载最开始的纹理时黑色的，过一会等纹理正在加载好了，才是正常的。                                      
                                             

material.map
// 使用：
// 材质的 map 属性设为纹理 texture
// 一个已经画出来了的模型可以动态修改其纹理:
	mesh.material.map = texture2; // 需要再次调用render
// color设置 会和纹理综合作用！！！                                            


纹理坐标:
// 将图片的像素位置，映射到 [-1,1]*[-1,1]的区间上，然后设置几何体每个顶点对应的图片坐标（即纹理坐标）
// 纹理是一个独立的对象，几何体对象的每个顶点有对应的纹理坐标（默认就是自身的归一化的坐标）

设置顶点对应的纹理：
// Geometry 的 faceVertexUvs : 
	// geometry.faceVertexUvs[0][0]=[v2_1, v2_2, v2_3]  
	// 每个v2是 new THREE.Vector2(0.2,0.2)这样的 x,y都在[0,1]之间。
	// 每个face有3个顶点，所以有3个纹理坐标与之对应
// BufferGeometry 的 attributes.uv
	// geometry.attributes.uv = new THREE.BufferAttribute(arr, 2);
	// arr就是 [x1,y1,x2,y2,…………]这样的数组


```

#### 材质数组

```js
var mesh = new THREE.Mesh(geometry, materialArr);
	// 多个材质，但每个三角形绘制时只能使用一个
	// 这由每个face的materialIndex决定
	geometry.faces[4].materialIndex = 1;
	bufferGeometry.groups // bufferGeo由groups配置决定，这个配置较灵活，例：
	bufferGeometry.groups[i] = {start:0,count:9,materialIndex:1} // 表示从第0个顶点开始，一共9个顶点（即3个三角形）采用第1个材质。

// 内置的几何体，如box，sphere 都有默认的materialIndex设置！（立方体6个面，12个三角形都设了）
```

#### 纹理的变换处理

纹理可不只是傻傻的加载一张图片就可以了！

```js
// 重复列阵：
texture.wrapS = THREE.RepeatWrapping;  // 设置水平方向的重复方式
texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set(4, 2);   // 水平方向重复4个，垂直2个（4*2）

// 偏移
texture.offset = new THREE.Vector2(0.3, 0.1)
texture.offset.set(0.25,0.25);

// 偏移与列阵同时设置时，注意偏移的始终是单个图片，列阵不过是重复，列阵不是产生新的图片！
```

```js
texture.rotation = Math.PI / 3;
texture.center.set(0.5, 0.5); // 设置纹理的旋转中心，默认(0,0)
```

