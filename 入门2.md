### 纹理（贴图）

#### 使用基础

```js
TextureLoader // 先new再加载，可以重复使用加载器
ImageLoader  // 加载图片后，直接创建纹理：
	var texture = new THREE.Texture(img);  // 必须设置 texture.needsUpdate = true; 纹理才可用
ObjectLoader
	loader.load('model.json',function (obj) {...}  // 得到的obj是一个可以加入scene的Object3D
    // 需要json遵循 three.js规则
// 同步加载：
    var texture = textureLoader.load(url);  // 另外两个loader可以这样吗？
    // 经过测试，这样加载最开始的纹理时黑色的，过一会等纹理正在加载好了，才是正常的。                                              
// canvas纹理：
let texture = new THREE.CanvasTexture(canvas);  // canvas可以不在document中！ 可以使用canvas的2d功能！
// video纹理
let texture = new THREE.VideoTexture(video);  // 普通的 <video/>                                             
                                             

material.map
// 使用：
// 材质的 map 属性设为纹理 texture
// 一个已经画出来了的模型可以动态修改其纹理:
	mesh.material.map = texture2; // 需要再次调用render
// color设置 会和纹理综合作用！！！                                            


纹理坐标:
// 将图片的像素位置，映射到 [-1,1]*[-1,1]的区间上，然后设置几何体每个顶点对应的图片坐标（即纹理坐标）
// 纹理是一个独立的对象，几何体对象的每个顶点有对应的纹理坐标（默认就是自身的归一化的坐标）

设置顶点对应的纹理：
// Geometry 的 faceVertexUvs : 
	// geometry.faceVertexUvs[0][0]=[v2_1, v2_2, v2_3]  
	// 每个v2是 new THREE.Vector2(0.2,0.2)这样的 x,y都在[0,1]之间。
	// 每个face有3个顶点，所以有3个纹理坐标与之对应
// BufferGeometry 的 attributes.uv
	// geometry.attributes.uv = new THREE.BufferAttribute(arr, 2);
	// arr就是 [x1,y1,x2,y2,…………]这样的数组


```

#### 数组材质

```js
var mesh = new THREE.Mesh(geometry, materialArr);
	// 多个材质，但每个三角形绘制时只能使用一个
	// 这由每个face的materialIndex决定
	geometry.faces[4].materialIndex = 1;
	bufferGeometry.groups // bufferGeo由groups配置决定，这个配置较灵活，例：
	bufferGeometry.groups[i] = {start:0,count:9,materialIndex:1} // 表示从第0个顶点开始，一共9个顶点（即3个三角形）采用第1个材质。

// 内置的几何体，如box，sphere 都有默认的materialIndex设置！（立方体6个面，12个三角形都设了）
```

#### 纹理的变换处理

纹理可不只是傻傻的加载一张图片就可以了！

```js
// 重复列阵：
texture.wrapS = THREE.RepeatWrapping;  // 设置水平方向的重复方式
texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set(4, 2);   // 水平方向重复4个，垂直2个（4*2）
texture.repeat.x = 20;
texture.repeat= new THREE.Vector2(20,1)

// 偏移
texture.offset = new THREE.Vector2(0.3, 0.1)
texture.offset.set(0.25,0.25);

// 偏移与列阵同时设置时，注意偏移的始终是单个图片，列阵不过是重复，列阵不是产生新的图片！
```

```js
texture.rotation = Math.PI / 3;
texture.center.set(0.5, 0.5); // 设置纹理的旋转中心，默认(0,0)
```

### 常用贴图（1+3种）

除了上面提到的map，还有normalMap、bumpMap、specularMap。

#### 凸凹纹理和法线纹理

普通的纹理对象，配置在不同的属性上，表达的信息不同

```js
// 法线纹理：图片的rgb分量表示的是法线xyz，从而图片描述了物体表面的凸凹细节！
normalMap: normalMap,
normalScale: new THREE.Vector2( 0.8, 0.8 )  // 表示深浅程度

// 凸凹纹理： 图片像素的灰度值 描述物体表面的凸凹细节！
bumpMap: bumpMap,
bumpScale: 12   // 表示深浅程度

// 注意：
// 凸凹纹理，法线纹理，在 MeshBasicMaterial和MeshLambertMaterial中不存在！！存在于具有高光属性的材质中！
// 这两个纹理 都是表达表面凹凸细节的，但显然表达方向的法线贴图信息更丰富。
// 如果写了两个将采用法线纹理，忽略凸凹纹理。
```

#### 高光贴图

```js
// 高光材质 specular属性 描述了镜面反射能力，但如果物体表面不同地方的镜面反射能力不同，如人脸，就要借助高光贴图了：
specularMap: specularMap   // 用纹理的rgb值 表达镜面反射的能力
```
### 其他贴图

#### 光照贴图（或阴影贴图）

``` js
// 设置阴影，通常无需设置
lightMap: textureLight  // 设置的是【阴影区域的纹理】，所以通常在 receiveShadow 的地方设置！
// 阴影贴图 和 普通的贴图基本一样，不过相反的是：光线越弱，贴图越明显。

第2套纹理坐标:
// 贴图就要有纹理坐标，阴影纹理坐标就是【第2套纹理坐标】
// 通常可以直接采用第一套纹理坐标(用于普通纹理，法线纹理等) 作为阴影的纹理坐标，于是通常这么设置：
bufferGeometry.attributes.uv2 = bufferGeometry.attributes.uv;  
geometry.faceVertexUvs[1] = geometry.faceVertexUvs[0];  
```
#### 环境贴图

```js
// 环境纹理 由6张图片 组成： 
const cubeTexture = new THREE.CubeTextureLoader()
  .setPath("/person/")
  .load([
    "posx.jpg",   // 看向x轴正方向的图片
    "negx.jpg",   // 看向x轴负方向的图片
    "posy.jpg",
    "negy.jpg",
    "posz.jpg",
    "negz.jpg"
  ]);


// 加入环境：
scene.background = cubeTexture;  
// 3d场景有了环境，就像VR一样。  
// 注意：前提是你的相机是 perspective模式的，不能是orthographic的


// 这样配置材质，让反光材质，反射出周围的环境！！
envMap: cubeTexture    // 让环境的光 反映到物体上（不需要则不用配置）

```

#### 数据生成纹理（DataTexture）

示例：

``` js
function generateMaterial(width = 32, height = 32) {
  const size = width * height; //像素大小
  const data = new Uint8Array(size * 4); // size*4：rgba 每个像素4个字节
  for (let i = 0; i < size * 4; i += 4) {   
    data[i] = 255 * Math.random();
    data[i + 1] = 255 * Math.random();
    data[i + 2] = 255 * Math.random();    
    data[i + 3] = 255 * 0.5;
  }
  const texture = new THREE.DataTexture(data, width, height, THREE.RGBAFormat);
  texture.needsUpdate = true;
  var material = new THREE.MeshPhongMaterial({
    map: texture, 
    transparent: true //注意，这个一定要设，否则前面生成的透明度无效
  })
  return material;
}

```

### 相机与渲染

#### 相机深入

![image-20201217193203840](E:\MGh\three-study\image-20201217193203840.png)

机械、工业设计领域常常采用正投影(平行投影), 大型游戏场景往往采用透视投影(中心投影)

``` js
new OrthographicCamera( left, right, top, bottom, near, far )   // 视区形成一个长方体
new PerspectiveCamera( fov, aspect, near, far )    // 视区形成一个长方椎体， fov 0-180度，一般45-90，默认50
// 注意：超出视区的物体，都将无法显示！


.matrixWorldInverse  // 相机对象的视图矩阵 的逆矩阵。---相机视角 【这个矩阵 由相机的位置+相机的lookAt 决定】
		.position
		.lookAt(vec3)
.projectionMatrix  // 投影映射矩阵 --- canvas坐标，归一化  【这个矩阵 由构造相机时 决定】
// 实际上 每个物体的绘制 最终都是要 *matrixWorldInverse*projectionMatrix 的


.projectionMatrixInverse // projectionMatrix 的逆矩阵

```

#### 自适应渲染

窗口变了，如何让渲染自适应？

``` js
window.onresize = function(){
    ... ...
}
```
分三步（修改渲染器，修改相机参数，更新投影矩阵）：

```js
renderer.setSize(window.innerWidth,window.innerHeight);

// 正投影相机：
camera.left = -W/2;
camera.right = W/2;
camera.top = H/2;
camera.bottom = -H/2;
// 透视投影相机：
camera.aspect = window.innerWidth/window.innerHeight;

camera.updateProjectionMatrix ();
```

### 精灵模型

创建精灵模型对象不需要创建几何体对象`Geometry`，可以理解为已经内部封装了一个平面矩形几何体`PlaneGeometry`，不同的是精灵模型的矩形平面会始终平行于Canvas画布

```js
SpriteMaterial
// 常见属性： color，map，等
// 特有属性：rotation

  
```

在使用透视投影相机对象的时候，精灵模型对象显示的大小和网格模型一样受距离相机的距离影响，也就是距离越远，显示效果越小。

``` js
sprite.scale.set(10, 10); // 设置精灵大小用scale (缩放z无意义)
sprite.position.set(0, 0, 900);
```

在三维场景中把精灵模型作为一个模型的标签，标签上可以显示一个写模型的信息

足够多的精灵模型对象，构建一个粒子系统，来模拟一个下雨、森林、或下雪的场景效果

### API 补充

``` js
THREE.RGBFormat   // 对应于 gl.RGB
THREE.RGBAFormat   // 对应于 gl.RGBA
```



### 待强化

spotLight和directionalLight的方向该怎么设置？？———— 手电筒，发光镜

LightHelper的设置



高光材质的使用（透明度玻璃管？？）

纹理的旋转

http://localhost:8080/examples/#webgl_materials_shaders_fresnel   // 小球

http://localhost:8080/examples/#webxr_vr_sandbox  // 反光镜

http://localhost:8080/examples/#physics_ammo_terrain // 曲面上滚动的小球

